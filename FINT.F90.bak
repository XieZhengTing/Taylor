

    !********************************************************
    !*                                                      *
    !********************************************************
    !************************* MEGA *************************
    !********************************************************
    !*                                                      *
    !********* Meshfree Explicit Galerkin Analysis **********
    !*                                                      *
    !*                                                      *
    !*                                                      *
    !*     Copyright 2016 Michael C Hillman                 *
    !*                                                      *
    !********************************************************
    SUBROUTINE CONSTRUCT_FINT(GWIN,    GVOL,       GNUMP,        GCOO,  GCOO_CUURENT,   &   !FROM MAIN
    GSM_LEN, GSM_AREA,   GSM_VOL,      GNSNI_FAC,      &   !FROM MAIN
    GGHOST,  GPROP,      GSTATE,       GSTRESS,        &   !FROM MAIN
    GSTRAIN, G_H_STRESS, G_S_STRESS, GDINC,      GDINC_TOT,    GMAT_TYPE,                    &   !FROM MAIN
    GEBC_NODES,                                               &   !FROM MAIN
    GN,      GSTART,     DIM_NN_LIST,                  &   !FROM HANDLER
    GSTACK,  GSTACK_SHP, GSTACK_DSHP,  GSTACK_DDSHP,  GMAXN,  GINVK, LINIT,   &   !FROM HANDLER
    FINT,    FEXT,       DLT_FINT,   GCHAR_DIST,   GMAX_WVEL, &
        LOCAL_DX_STRESS, LOCAL_DY_STRESS, LOCAL_DZ_STRESS, & !OUTPUT
    G_X_MOM, G_Y_MOM, G_Z_MOM,MODEL_BODYFORCE,GINT_WORK, MODEL_BODY_ID, GSTRAIN_EQ,DLT)

    !
    ! FUNCTION OF THIS SUBROUTINE:
    !
    ! BASED ON CURRENT DISPLACEMENT INCREMENT, STATE VARIABLES, AND SO ON,
    ! COMPUTE THE INTERNAL FORCE FOR A SET OF NODES GIVEN THEIR COORDINATES,
    ! DILATIONS, AND SO ON.
    !
    !VOIGT ORDERING:
    !XX, YY, ZZ, YZ, XZ, XY
    !
    USE FINT_FUNCTIONS
    USE CONTROL
    USE omp_lib
    !
    IMPLICIT NONE
    !
    !
    !
    !*********************************************************
    !********************* DECLAIRATIONS *********************
    !*********************************************************
    !
    !
    !********** GLOBAL VARIABLES **********
    !
    !GLOBAL IN
    !
    !
    !DISCRETIZATION INFO
    !
    INTEGER:: GNUMP                         !NUMBER OF NODES
    DOUBLE PRECISION:: GCOO(3,GNUMP)        !COORDINATE FOR EACH NODE
    DOUBLE PRECISION:: GCOO_CUURENT(3,GNUMP) !CUURENT COORDINATE FOR EACH NODE
    DOUBLE PRECISION:: GWIN(3,GNUMP)        !WINDOWS FOR EACH NODE
	DOUBLE PRECISION, SAVE, ALLOCATABLE:: GWIN0(:,:)
	
    DOUBLE PRECISION:: GSM_LEN(6,GNUMP)     !SMOOTHING LENGTHS FOR EACH NODE
    ! (1-6) = (+X, -X, +Y, -Y, +Z, -Z)
    DOUBLE PRECISION:: GSM_VOL(GNUMP)       !VOLUME OF SMOOTHING ZONE
    DOUBLE PRECISION:: GSM_AREA(3,GNUMP)    !AREAS OF SMOOTHING ZONE SIDES
    INTEGER:: GN(GNUMP)                     !NUMBER OF NEIGHBORS FOR EACH NODE
    INTEGER:: GSTART(GNUMP)                 !START LOCATION OF NODE NEIOGHBORS IN STACK
    INTEGER:: DIM_NN_LIST                   !SIZE OF NEIGHBOR STACK
    INTEGER:: GSTACK(DIM_NN_LIST)           !NEIGHBORS FOR EACH NODE (STACKED)
    DOUBLE PRECISION:: GSTACK_SHP(DIM_NN_LIST)       !SHAPES (STACKED)
    DOUBLE PRECISION:: GSTACK_DSHP(3,DIM_NN_LIST)       !SHAPES (STACKED)
    DOUBLE PRECISION:: GSTACK_DDSHP(6,DIM_NN_LIST)       !SHAPES (STACKED)
    DOUBLE PRECISION:: GINVK(3,3,GNUMP)

    DOUBLE PRECISION:: GCHAR_DIST(GNUMP),   GMAX_WVEL(GNUMP)

    INTEGER:: GMAXN                             !MAX NUMBER OF NEIGHBORS FOR ALL NODES
    INTEGER:: GGHOST(GNUMP)                 !FLAG FOR GHOST NODES (GHOST = 1)

    LOGICAL:: GEBC_NODES(GNUMP)

    DOUBLE PRECISION:: GVOL(GNUMP)          !VOLUME OF EACH NODE
    DOUBLE PRECISION:: GNSNI_FAC(3,GNUMP)

    !
    !STATE AND FIELD VARIABLES
    !
    DOUBLE PRECISION:: GSTRESS(6,GNUMP)     !CAUCHY STRESS OF EACH NODE
    DOUBLE PRECISION:: GSTRAIN(6,GNUMP)     !CAUCHY STRAIN OF EACH NODE
    DOUBLE PRECISION:: GSTATE(20,GNUMP)     !STATE VARIABLES OF EACH NODE
    DOUBLE PRECISION:: GPROP(30,GNUMP)     !MATERIAL PROPERTIES OF EACH NODE
    DOUBLE PRECISION:: GDINC(3*GNUMP) ,GDINC_TOT(3*GNUMP)      !DISPLACEMENT INCREMENT (PREDICTOR) OF EACH NODE
    INTEGER::          GMAT_TYPE(GNUMP)    !MATERIAL TYPE OF EACH NODE
    DOUBLE PRECISION:: G_H_STRESS(6,GNUMP)!GC
    DOUBLE PRECISION:: G_S_STRESS(6,GNUMP)!GC
    DOUBLE PRECISION:: DLT
    !
    !GLOBAL OUT
    DOUBLE PRECISION:: FINT(GNUMP*3), FEXT(GNUMP*3)
    DOUBLE PRECISION:: DLT_FINT
    
    DOUBLE PRECISION:: GSTRAIN_EQ(GNUMP)     !EQUIVALENT PLASTIC STARIN OF EACH NODE
    !
    !********** LOCAL VARIABLES **********
    INTEGER:: I,J,K,L,JJ               !INDICIES
    DOUBLE PRECISION:: LCOO(3)    !COORDINATE AT A NODE IN INITIAL CONFIGURATION
    DOUBLE PRECISION:: LCOO_T(3)    !COORDINATE AT A NODE IN CURRENT CONFIGURATION
    DOUBLE PRECISION:: LWIN(3) !WINDOW A NODE
    DOUBLE PRECISION:: VOL !NODAL VOLUME (ACTUAL INTEGRATION WEIGHT
    DOUBLE PRECISION:: LSM_LEN(6)  !SMOOTHING LENGTHS A NODE
    DOUBLE PRECISION:: LSM_PTS(3,6)  !SMOOTHING POINT POSITION
    DOUBLE PRECISION:: SM_COO(3)     !TEMPORARY SMOOTHING POINT POSITION
    DOUBLE PRECISION:: LSM_VOL       !VOLUME OF SMOOTHING ZONE
    DOUBLE PRECISION:: LSM_AOV(6)   !AREA OVER VOLUME OF SMOOTHING ZONE SIDES/ZONES
    DOUBLE PRECISION:: LSTRESS(6)     !CAUCHY STRESS OF A NODE
    DOUBLE PRECISION:: LSTRESS_PREDICTOR(6)     !ELASTIC PREDICTOR STRESS
    DOUBLE PRECISION:: LSTRAIN(6)
    DOUBLE PRECISION:: L_H_STRESS(6)!GC: FOR VISCOELASTIC
    DOUBLE PRECISION:: L_S_STRESS(6)!GC


    DOUBLE PRECISION:: G_X_MOM(GNUMP),G_Y_MOM(GNUMP),G_Z_MOM(GNUMP)


    DOUBLE PRECISION:: LSTATE(20)      !STATE VARIABLES OF A NODE
    DOUBLE PRECISION:: LPROP(30)     !MATERIAL PROPERTIES OF A NODE
    INTEGER:: LMAT_TYPE    !MATERIAL TYPE OF EACH NODE
    LOGICAL:: SELF_EBC
    !
    INTEGER:: LSTART              !LOCATION OF START IN STACK
    INTEGER:: LGHOST              !FLAG FOR GHOST NODES (GHOST = 1)
    INTEGER:: LSTACK(GMAXN)       !LOCAL LIST/STACK OF NEIGHBORS
    INTEGER:: LN                  !NUMBER OF NEIGHBORS FOR A NODE
    DOUBLE PRECISION:: LVOL       !VOLUME OF A NODE
    DOUBLE PRECISION:: SHP(GMAXN), SHPD(3,GMAXN), SHPD_TRASH(3,GMAXN)       !SHAPE FUNCTIONS AND GRADIENTS
    DOUBLE PRECISION:: SHPDTMP(3,GMAXN)       !TEMPORARY SHAPE FUNCTIONS AND GRADIENTS

    DOUBLE PRECISION:: SHPD_SM(3,GMAXN)        !SHAPE FUNCTION SMOOTHED GRADIENTS
    DOUBLE PRECISION:: SHPDD_SM(6,GMAXN)       !SHAPE FUNCTION SMOOTHED SMOOTHED GRADIENTS
    DOUBLE PRECISION:: SHPDTEMP(9) !TEMPORARY VARIABLE FOR SHAPES FOR STABILZIATION
    DOUBLE PRECISION:: SHP6(GMAXN,6), SHPD6(3,GMAXN,6) !SHAPE FUNCTION AND SM. GRAD. AT SMOOTHING POINTS
    DOUBLE PRECISION:: LMAT(3,3) !INCREMENTAL DEFORMATION GRADIENT WITH RESPECT TO THE CURRENT TIME STEP
    DOUBLE PRECISION:: LDINC(3,GMAXN),LDINC_TOT(3,GMAXN)       !DISPLACEMENT INCREMENT (PREDICTOR) OF A NODESTRAIN
    DOUBLE PRECISION:: LCOO_CUURENT(3,GMAXN)  !CURRENT COORDINATES OF THE NEIGBORS
    DOUBLE PRECISION:: LCOONE(3,GMAXN)  !ORIGINAL COORDINATES OF THE NEIGBORS
    DOUBLE PRECISION:: B_TEMP(3,3), B_INV_TEMP(3,3) !GC
    DOUBLE PRECISION:: STRAIN(6)       !INCREMENTALLY OBJECTIVE STRAIN
    DOUBLE PRECISION:: ELAS_MAT(6,6)
    DOUBLE PRECISION:: BMAT(6,3)
    DOUBLE PRECISION:: BMAT_T(3,6)
    DOUBLE PRECISION:: FINT3(3),FINT3_EXT(3),INVK(3,3)
    DOUBLE PRECISION:: ROT(6,6) !ROTATION MATRIX
    LOGICAL:: LINIT
    DOUBLE PRECISION:: FMAT(3,3), IFMAT(3,3),X_0(3),X_t(3), DX_t(3,1), PKSTRESS(3,3), TEMP_STRESS(3,3)
    DOUBLE PRECISION, ALLOCATABLE:: FINT_TEMP(:,:,:), FEXT_TEMP(:,:,:)
    DOUBLE PRECISION:: DET
    !DOUBLE PRECISION:: FINT_TEMP(20,3,GNUMP)
    INTEGER:: ID_RANK

    !0329
    DOUBLE PRECISION:: PMAT(6,3)
    DOUBLE PRECISION:: FBOD(3),FGRAV(3)
    !DOUBLE PRECISION:: MODEL_BODYFORCE(3)
    !0702
    DOUBLE PRECISION:: MODEL_BODYFORCE(3,GNUMP)
    DOUBLE PRECISION:: LBOD(3)


    !NSNI
    INTEGER::XMAP(3),YMAP(3),ZMAP(3)
    DOUBLE PRECISION::XLMAT(3,3),YLMAT(3,3),ZLMAT(3,3)
    DOUBLE PRECISION:: DX_STRAIN(6), DY_STRAIN(6), DZ_STRAIN(6)
    DOUBLE PRECISION::  LOCAL_DX_STRESS(6,GNUMP)
    DOUBLE PRECISION::  LOCAL_DY_STRESS(6,GNUMP)
    DOUBLE PRECISION::  LOCAL_DZ_STRESS(6,GNUMP)

    DOUBLE PRECISION::  LDX_STRESS(6)
    DOUBLE PRECISION::  LDY_STRESS(6)
    DOUBLE PRECISION::  LDZ_STRESS(6)
    DOUBLE PRECISION:: CMAT(6,6), LAMDA, MU, LAMDA_PLUS_2MU
    DOUBLE PRECISION:: XBMAT(6,3), XBMAT_T(3,6), XFINT3(GMAXN,3)
    DOUBLE PRECISION:: YBMAT(6,3), YBMAT_T(3,6), YFINT3(GMAXN,3)
    DOUBLE PRECISION:: ZBMAT(6,3), ZBMAT_T(3,6), ZFINT3(GMAXN,3)
    DOUBLE PRECISION:: MAG_STAB_FINT,MAG_FINT

    DOUBLE PRECISION:: TEMP_DEBUG(3)

    DOUBLE PRECISION:: GINT_WORK
    DOUBLE PRECISION, ALLOCATABLE:: GINT_WORK_TEMP(:)
    !
    ! FOR TIME STEP CALCS
    !
    LOGICAL:: FIRST,NSNI_FLAG
    DOUBLE PRECISION:: STRESS_INC(6), STRAIN_INC(6), POISS, YOUNG, BULK, SHEAR,  &
        STRESS_INC_DEV(6), STRESS_INC_SPHR(6), STRAIN_INC_DEV(6), STRAIN_INC_SPHR(6),  &
        NORM_STRESS_INC_DEV, NORM_STRESS_INC_SPHR, NORM_STRAIN_INC_DEV, NORM_STRAIN_INC_SPHR,   &
        SHEAR_TRIAL, BULK_TRIAL, PMOD, DENSITY, MAXMOD, MAX_VEL,   &
        DIST, XJ, YJ, ZJ, CHAR_DIST, DLT_TEMP, XI, YI, ZI
    DOUBLE PRECISION:: D(6)
    
          !0703 contact
    INTEGER :: MODEL_BODY_ID(GNUMP)
    INTEGER :: LOCAL_BODY_ID, LOCAL_BODY_ID_2, II, P,KK
         ! 0703      
    DOUBLE PRECISION:: F_INT_C(3), MU1, MU_NEW, MU_NEW2, X2(3), X1(3), TEMP, F_N, XNORM(3), F_T1, F_T2, F_T3, F_TT, F_INT_C_TEMP(3),F_T
	!LOGICAL::      KCONTACT
    DOUBLE PRECISION:: DX(3), LITTLE_DX(3),LENGTH_DX,LENGTH_LITTLE_DX
	
    DOUBLE PRECISION:: NSNI_LIMITER
    !
    !
    !
    !
    !*********************************************************
    !******************** EXECUTABLE CODE ********************
    !*********************************************************
    !
    !GINT_WORK = 0.0d0
    !
    !INITIALIZE FINT
    !
    !
    !
    !LOOP OVER THE NODE STACK
    !
    !LET OPEN-MP DECIDE HOW TO DO THE DO-LOOP
    !
    FINT = 0.0d0
    DET = 1.d0
    !REDUCTION(+:FINT)
    !
    ALLOCATE(FINT_TEMP(NCORES_INPUT,3,GNUMP))
    FINT_TEMP = 0.D0

    ALLOCATE(FEXT_TEMP(NCORES_INPUT,3,GNUMP))
    FEXT_TEMP = 0.D0

    ALLOCATE(GINT_WORK_TEMP(NCORES_INPUT))
    GINT_WORK_TEMP = 0.0d0

        IF (LINIT) THEN
          ALLOCATE(GWIN0(3,GNUMP))
		  GWIN0 = GWIN
		END IF
		
		
    !$OMP PARALLEL DEFAULT(FIRSTPRIVATE) SHARED( GNUMP, GCOO, GCOO_CUURENT, GWIN, GSM_LEN, GSM_VOL, GSM_AREA, GN, GSTART, &
    !$OMP                                       DIM_NN_LIST, GSTACK, GSTACK_SHP, GSTACK_DSHP, GSTACK_DDSHP, GINVK, &
    !$OMP                                       GCHAR_DIST,GMAX_WVEL, GMAXN, GGHOST, GEBC_NODES, GVOL, GNSNI_FAC, &
    !$OMP                                       GSTRESS, LOCAL_DX_STRESS, LOCAL_DY_STRESS, LOCAL_DZ_STRESS, &
    !$OMP                                       GSTRAIN, &
    !$OMP                                       GSTATE, GPROP, GDINC,GDINC_TOT, GMAT_TYPE, FINT, DLT_FINT, FINT_TEMP, FEXT_TEMP, &
    !$OMP                                       GINT_WORK_TEMP,GINT_WORK,GSTRAIN_EQ)

    ID_RANK = OMP_get_thread_num()  !OMPJOE

    !$OMP DO
    DO I = 1, GNUMP
        !
        !
        !GRAB NODE INFORMATION FROM LIST
        !
        LCOO(:) = GCOO(:,I)
        LCOO_T(:) = GCOO_CUURENT(:,I)
        VOL = GVOL(I)
        LWIN(:) = GWIN(:,I)
        LSM_LEN(:) = GSM_LEN(:,I)
        LN = GN(I)
        LSTART = GSTART(I)
        LGHOST = GGHOST(I)
        LVOL = GVOL(I)
        LPROP = GPROP(:,I)
        LMAT_TYPE = GMAT_TYPE(I)
        LOCAL_BODY_ID = MODEL_BODY_ID(I)
        
        !
        IF (GEBC_NODES(I)) THEN
            SELF_EBC = .TRUE.
        ELSE
            SELF_EBC = .FALSE.
        END IF
        !
        ! RECALL THE NODE STRESS AND STATE VARIABLES
        !
        DO J = 1, 6
            LSTRESS(J) = GSTRESS(J,I)
            LSTRAIN(J) = GSTRAIN(J,I)

            IF(LMAT_TYPE == 4) THEN
                L_H_STRESS(J) = G_H_STRESS(J,I)!GC
                L_S_STRESS(J) = G_S_STRESS(J,I)!GC
            END IF
        END DO

        DO J = 1, 30
            LPROP(J) = GPROP(J,I)
        END DO

        DO J = 1, 3
            LBOD(J) = MODEL_BODYFORCE(J,I)
        END DO

        DO J = 1, 20
            LSTATE(J) = GSTATE(J,I)
        END DO
        !
        ! GET THE NEIGHBOR LIST
        !
        DO J = 1, LN
            LSTACK(J) = GSTACK(LSTART+J-1)
        END DO
        !
        ! GET THE INCREMENTS OF DISPLACEMENTS FOR NEIGHBORS
        !
        DO J = 1, LN
            JJ = LSTACK(J)
            LDINC(1,J) = GDINC((JJ-1)*3+1)
            LDINC(2,J) = GDINC((JJ-1)*3+2)
            LDINC(3,J) = GDINC((JJ-1)*3+3)
        END DO
        !
        ! GET THE GENERALIZED DISPLACEMENTS FOR NEIGHBORS
        !
        DO J = 1, LN
            JJ = LSTACK(J)
            LDINC_TOT(1,J) = GDINC_TOT((JJ-1)*3+1)
            LDINC_TOT(2,J) = GDINC_TOT((JJ-1)*3+2)
            LDINC_TOT(3,J) = GDINC_TOT((JJ-1)*3+3)
        END DO
        !
        ! GET THE ORIGINAL COORDINATES FOR NEIGHBORS
        !
        DO J = 1, LN
            JJ = LSTACK(J)
            LCOONE(1,J) = GCOO(1,JJ)
            LCOONE(2,J) = GCOO(2,JJ)
            LCOONE(3,J) = GCOO(3,JJ)
        END DO
        !
        !
        ! GET THE CURRENT COORDINATES FOR NEIGHBORS
        !
        DO J = 1, LN
            JJ = LSTACK(J)
            LCOO_CUURENT(1,J) = GCOO_CUURENT(1,JJ)
            LCOO_CUURENT(2,J) = GCOO_CUURENT(2,JJ)
            LCOO_CUURENT(3,J) = GCOO_CUURENT(3,JJ)
        END DO
        !
        !IF IT IS LAGRANGIAN AND IT IS NOT THE FIRST STEP, RECALL SHAPE FUNCTIONS
		!
        IF ((LLAGRANGIAN).AND.(.NOT.LINIT)) THEN
            DO J = 1, LN
                SHP(J) =   GSTACK_SHP(LSTART+J-1)
                SHPD(1,J) = GSTACK_DSHP(1,LSTART+J-1)
                SHPD(2,J) = GSTACK_DSHP(2,LSTART+J-1)
                SHPD(3,J) = GSTACK_DSHP(3,LSTART+J-1)
            END DO

            IF (LFINITE_STRAIN) THEN

                FMAT = 0.0d0
                FMAT(1,1) = 1.d0
                FMAT(2,2) = 1.d0
                FMAT(3,3) = 1.d0
                !
                DO K = 1, 3
                    DO L = 1, 3
                        DO J = 1, LN
                            !JJ = LSTACK(J)
                            !FMAT(K,L) = FMAT(K,L) +  SHPD(L,J)*GCOO_CUURENT(K,JJ)
                            FMAT(K,L) = FMAT(K,L) +  SHPD(L,J)*LDINC_TOT(K,J)
                        END DO !J = 1, LN (COMPUTE THE INCREMENTAL DEFORMATION GRADIENT)
                    END DO
                END DO
                CALL DETERMINANT(FMAT,DET)
                !
                !
                SHPDTMP(:,1:LN)=SHPD(:,1:LN)
                SHPD(:,1:LN) = 0.0d0

                !CALL INVERSE(FMAT, 3, IFMAT)
                CALL INV3(FMAT,  IFMAT)
                DO J = 1, LN
                    DO K = 1, 3
                        SHPD(1,J) = SHPD(1,J) + SHPDTMP(K,J)*IFMAT(K,1)
                        SHPD(2,J) = SHPD(2,J) + SHPDTMP(K,J)*IFMAT(K,2)
                        SHPD(3,J) = SHPD(3,J) + SHPDTMP(K,J)*IFMAT(K,3)
                    END DO
                END DO

            END IF


        ELSE
            !
            ! TODO: CONDENSE ALL SHAPE FUNCTION CALCULATIONS
            !
            IF (ITYPE_INT.EQ.0) THEN
                !
                ! DIRECT NODAL INTEGRATION
                !
                IF (LLAGRANGIAN) THEN

                    CALL RK1(LCOO, RK_DEGREE, RK_PSIZE, RK_CONT, RK_IMPL,GCOO, GWIN, GNUMP, LSTACK, LN, GMAXN, GEBC_NODES,SELF_EBC, &
                        QL, QL_COEF,QL_LEN, &
                        SHP, SHPD,SHSUP)


                ELSE !GCOO_CUURENT
                    CALL RK1(LCOO_T, RK_DEGREE, RK_PSIZE, RK_CONT, RK_IMPL,GCOO_CUURENT, GWIN, GNUMP, LSTACK, LN, GMAXN, GEBC_NODES,SELF_EBC, &
                        QL, QL_COEF,QL_LEN, &
                        SHP, SHPD, SHSUP)
                    
                    ! CALCULATE THE DEFORMATION GRADIENT
                    B_TEMP = 0.D0
                    DO K = 1, 3
                        DO L = 1, 3
                            DO J = 1, LN
                                B_TEMP(K,L) = B_TEMP(K,L) +  SHPD(L,J)*LCOONE(K,J)
                            END DO 
                        END DO
                    END DO
                    CALL INVERSE(B_TEMP, 3, B_INV_TEMP) 
                    FMAT = B_INV_TEMP
                    !
                    ! STORE THE SHP FOR PHY DISPLACEMENT/VEL CACULATION FOR DNI
                    !
                    DO J = 1, LN
                        GSTACK_SHP(LSTART+J-1) = SHP(J)
                        GSTACK_DSHP(1,LSTART+J-1) = SHPD(1,J)
                        GSTACK_DSHP(2,LSTART+J-1) = SHPD(2,J)
                        GSTACK_DSHP(3,LSTART+J-1) = SHPD(3,J)
                    END DO

                END IF

                CONTINUE

            ELSEIF ((ITYPE_INT.EQ.2).OR.(ITYPE_INT.EQ.1)) THEN
                !
                ! NSNI
                !
                ! GET THE SMOOTHING INFORMATION
                ! (1-6) = (+X, -X, +Y, -Y, +Z, -Z)
                !
                DO J = 1, 3
                    DO K = 1, 6
                        LSM_PTS(J,K) = LCOO_T(J)
                    END DO
                END DO
                LSM_PTS(1,1) = LCOO_T(1) + LSM_LEN(1)
                LSM_PTS(1,2) = LCOO_T(1) - LSM_LEN(2)
                LSM_PTS(2,3) = LCOO_T(2) + LSM_LEN(3)
                LSM_PTS(2,4) = LCOO_T(2) - LSM_LEN(4)
                LSM_PTS(3,5) = LCOO_T(3) + LSM_LEN(5)
                LSM_PTS(3,6) = LCOO_T(3) - LSM_LEN(6)

                LSM_VOL = GSM_VOL(I)
                !
                ! COMPUTE SMOOTHED AREA OVER VOLUME
                !
                DO J = 1, 3
                    LSM_AOV((J-1)*2+1) = GSM_AREA(J,I) / LSM_VOL
                    LSM_AOV((J-1)*2+2) = GSM_AREA(J,I) / LSM_VOL
                END DO

                !
                !COMPUTE THE SHAPE FUNCTIONS AT GRADIENT SMOOTHING POINTS
                !
                DO J = 1, 6

                    SM_COO(:) = LSM_PTS(:,J)
                    CALL RK1(SM_COO, RK_DEGREE, RK_PSIZE, RK_CONT, RK_IMPL, GCOO_CUURENT, GWIN, GNUMP, LSTACK, LN, GMAXN, GEBC_NODES,SELF_EBC, &
                        QL, QL_COEF,QL_LEN, &
                        SHP, SHPD, SHSUP)

                    DO K = 1, LN
                    
                        SHP6(K,J) = SHP(K)
                        SHPD6(:,K,J) = SHPD(:,K)
                    END DO

                END DO !J = 1, 6 (COMPUTE THE SMOOTHED GRADIENTS)

                !
                ! FILL OUT THE SMOOTHED GRADIENT INFORMATION
                !
                DO K = 1, LN

                    SHPD(1,K) = (SHP6(K,1)*LSM_AOV(1) - SHP6(K,2)*LSM_AOV(2))
                    SHPD(2,K) = (SHP6(K,3)*LSM_AOV(3) - SHP6(K,4)*LSM_AOV(4))
                    SHPD(3,K) = (SHP6(K,5)*LSM_AOV(5) - SHP6(K,6)*LSM_AOV(6))

                END DO
                !
                IF (ITYPE_INT.EQ.2) THEN

                    !NSNI CALCS

                    DO K = 1, LN
                        !
                        ! SMOOTH X Y Z IN X DIRECTION
                        !
                        !XX
                        SHPDTEMP(1) = (SHPD6(1,K,1)*LSM_AOV(1) - SHPD6(1,K,2)*LSM_AOV(2)) !SMOOTH IN X DIRECTION

                        !XY
                        SHPDTEMP(2) = (SHPD6(2,K,1)*LSM_AOV(1) - SHPD6(2,K,2)*LSM_AOV(2)) !SMOOTH IN X DIRECTION

                        !XZ
                        SHPDTEMP(3) = (SHPD6(3,K,1)*LSM_AOV(1) - SHPD6(3,K,2)*LSM_AOV(2)) !SMOOTH IN X DIRECTION
                        !
                        ! SMOOTH X Y Z IN Y DIRECTION
                        !
                        !YX
                        SHPDTEMP(4) = (SHPD6(1,K,3)*LSM_AOV(3) - SHPD6(1,K,4)*LSM_AOV(4)) !SMOOTH IN Y DIRECTION

                        !YY
                        SHPDTEMP(5) = (SHPD6(2,K,3)*LSM_AOV(3) - SHPD6(2,K,4)*LSM_AOV(4)) !SMOOTH IN Y DIRECTION

                        !YZ
                        SHPDTEMP(6) = (SHPD6(3,K,3)*LSM_AOV(3) - SHPD6(3,K,4)*LSM_AOV(4)) !SMOOTH IN Y DIRECTION
                        !
                        ! SMOOTH X Y Z IN Z DIRECTION
                        !
                        !ZX
                        SHPDTEMP(7) = (SHPD6(1,K,5)*LSM_AOV(5) - SHPD6(1,K,6)*LSM_AOV(6)) !SMOOTH IN Z DIRECTION

                        !ZY
                        SHPDTEMP(8) = (SHPD6(2,K,5)*LSM_AOV(5) - SHPD6(2,K,6)*LSM_AOV(6)) !SMOOTH IN Z DIRECTION

                        !ZZ
                        SHPDTEMP(9) = (SHPD6(3,K,5)*LSM_AOV(5) - SHPD6(3,K,6)*LSM_AOV(6)) !SMOOTH IN Z DIRECTION

                        !XX
                        SHPDD_SM(1,K) = SHPDTEMP(1)
                        !YY
                        SHPDD_SM(2,K) = SHPDTEMP(5)
                        !ZZ
                        SHPDD_SM(3,K) = SHPDTEMP(9)
                        !XY
                        SHPDD_SM(4,K) = 0.5d0 * (SHPDTEMP(2) + SHPDTEMP(4))
                        !YZ
                        SHPDD_SM(5,K) = 0.5d0 * (SHPDTEMP(6) + SHPDTEMP(8))
                        !XZ
                        SHPDD_SM(6,K) = 0.5d0 * (SHPDTEMP(3) + SHPDTEMP(7))

                    END DO

                    !TODO: GET RID OF THESE ARRAYS, WE DONT DO LAGRANGIAN NSNI, SO ITS
                    !WASTING A BUNCH OF STORAGE

                    DO J = 1, LN
                        GSTACK_DDSHP(1,LSTART+J-1) = SHPDD_SM(1,J)
                        GSTACK_DDSHP(2,LSTART+J-1) = SHPDD_SM(2,J)
                        GSTACK_DDSHP(3,LSTART+J-1) = SHPDD_SM(3,J)
                        GSTACK_DDSHP(4,LSTART+J-1) = SHPDD_SM(4,J)
                        GSTACK_DDSHP(5,LSTART+J-1) = SHPDD_SM(5,J)
                        GSTACK_DDSHP(6,LSTART+J-1) = SHPDD_SM(6,J)
                    END DO

                END IF

                CALL RK1(LCOO_T, RK_DEGREE, RK_PSIZE, RK_CONT, RK_IMPL,GCOO_CUURENT, GWIN, GNUMP, LSTACK, LN, GMAXN, GEBC_NODES,SELF_EBC, &
                    QL, QL_COEF,QL_LEN, &
                    SHP, SHPD_TRASH, SHSUP)
                !
                ! STORE THE SHP FOR PHY DISPLACEMENT/VEL CACULATION FOR SNNI, DNI
                !
                DO J = 1, LN
                    GSTACK_SHP(LSTART+J-1) = SHP(J)
                END DO

            END IF



            IF ((LLAGRANGIAN).AND.(LINIT)) THEN

                DO J = 1, LN
                    GSTACK_SHP(LSTART+J-1) = SHP(J)
                    GSTACK_DSHP(1,LSTART+J-1) = SHPD(1,J)
                    GSTACK_DSHP(2,LSTART+J-1) = SHPD(2,J)
                    GSTACK_DSHP(3,LSTART+J-1) = SHPD(3,J)
                END DO

                IF (LFINITE_STRAIN) THEN

                    FMAT = 0.0d0
                    FMAT(1,1) = 1.d0
                    FMAT(2,2) = 1.d0
                    FMAT(3,3) = 1.d0
                    !

                    DO K = 1, 3
                        DO L = 1, 3
                            DO J = 1, LN
                                FMAT(K,L) = FMAT(K,L) +  SHPD(L,J)*LDINC_TOT(K,J)
                            END DO !J = 1, LN (COMPUTE THE INCREMENTAL DEFORMATION GRADIENT)
                        END DO
                    END DO
                    CALL DETERMINANT(FMAT,DET)
                    !
                    SHPDTMP(:,1:LN)=SHPD(:,1:LN)
                    SHPD(:,1:LN) = 0.0d0


                    !CALL INVERSE(FMAT, 3, IFMAT)
                    CALL INV3(FMAT,  IFMAT)

                    DO J = 1, LN
                        DO K = 1, 3
                            SHPD(1,J) = SHPD(1,J) + SHPDTMP(K,J)*IFMAT(K,1)
                            SHPD(2,J) = SHPD(2,J) + SHPDTMP(K,J)*IFMAT(K,2)
                            SHPD(3,J) = SHPD(3,J) + SHPDTMP(K,J)*IFMAT(K,3)

                        END DO

                    END DO
                END IF


            END IF

        END IF
        !
        ! COMPUTE STRAIN MEASURES
        !

            ! IF (.NOT.(LLAGRANGIAN)) THEN
		
                    ! FMAT = 0.0d0
                    ! FMAT(1,1) = 1.d0
                    ! FMAT(2,2) = 1.d0
                    ! FMAT(3,3) = 1.d0
                    ! !

                    ! DO K = 1, 3
                        ! DO L = 1, 3
                            ! DO J = 1, LN
                                ! FMAT(K,L) = FMAT(K,L) +  SHPD(L,J)*LDINC_TOT(K,J)
                            ! END DO !J = 1, LN (COMPUTE THE INCREMENTAL DEFORMATION GRADIENT)
                        ! END DO
                    ! END DO
					
					! FMAT_TRANS = TRANSPOSE(FMAT)
					
					! !COMPUTE GREEN'S STRAIN
					! E_STRAIN = MATMUL(FMAT_TRANS,FMAT)
					
                    ! DO K = 1, 3
                        ! DO L = 1, 3
						
						! E_STRAIN(K,L) = 0.0d0
						! END DO
						! END DO
					
                    ! CALL DETERMINANT(FMAT,DET)
					
			! END IF
					
					
        IF (LFINITE_STRAIN) THEN
            !
            ! COMPUTE THE INCREMENTAL DEFORMATION GRADIENT WITH RESPECT TO THE CURRENT TIME STEP
            !
            LMAT = 0.0d0
            !
            !

            DO K = 1, 3
                DO L = 1, 3
                    DO J = 1, LN
                        LMAT(K,L) = LMAT(K,L) +  SHPD(L,J)*LDINC(K,J)
                    END DO
                END DO
            END DO !J = 1, LN (COMPUTE THE INCREMENTAL DEFORMATION GRADIENT)
			
			! !COMPUTE THE CHANBGE IN LENGTHS OF SUPPORTS
			! INCREMENTALLY (IN PROGRESS!)
			
			! DO J=1,3
			
			  ! DX = 0.0d0
			  ! DX(J) = GWIN(J,I)
				
				! LENGTH_DX = DSQRT(DX(1)**2+DX(2)**2+DX(3)**2)
				
				! DO K = 1, 3
				  ! LITTLE_DX(K) = 0.0d0
					! DO L = 1, 3
					! LITTLE_DX(K) = LITTLE_DX(K) + LMAT(K,L)*DX(L)
					! END DO
				! END DO
				
				! LENGTH_LITTLE_DX = DSQRT(LITTLE_DX(1)**2+LITTLE_DX(2)**2+LITTLE_DX(3)**2)
				
				! GWIN(I,J) = GWIN(I,J) + GWIN(I,J) * LENGTH_LITTLE_DX/LENGTH_DX
				! GWIN(I,J) = MIN(GWIN0(I,J)*2.0d0,GWIN(I,J))
				! GWIN(I,J) = MAX(GWIN0(I,J)/2.0d0,GWIN(I,J))
				
			! END DO
			

            IF (ITYPE_INT.EQ.2) THEN

                !NSNI

                !XX
                !YY
                !ZZ
                !XY
                !YZ
                !XZ

                XMAP(1) = 1 !X,X
                XMAP(2) = 4 !Y,X
                XMAP(3) = 6 !Z,X

                YMAP(1) = 4 !X,Y
                YMAP(2) = 2 !Y,Y
                YMAP(3) = 5 !Z,Y

                ZMAP(1) = 6 !X,Z
                ZMAP(2) = 5 !Y,Z
                ZMAP(3) = 3 !Z,Z

                XLMAT = 0.0d0
                YLMAT = 0.0d0
                ZLMAT = 0.0d0

                DO K = 1, 3
                    DO L = 1, 3
                        DO J = 1, LN
                            XLMAT(K,L) = XLMAT(K,L) +  SHPDD_SM(XMAP(L),J)*LDINC(K,J)
                            YLMAT(K,L) = YLMAT(K,L) +  SHPDD_SM(YMAP(L),J)*LDINC(K,J)
                            ZLMAT(K,L) = ZLMAT(K,L) +  SHPDD_SM(ZMAP(L),J)*LDINC(K,J)
                        END DO
                    END DO
                END DO !J = 1, LN (COMPUTE THE INCREMENTAL DEFORMATION GRADIENT)

                CALL D_HUGHES_WINGET(LMAT,XLMAT, & !IN
                ROT,DX_STRAIN) !OUT

                CALL D_HUGHES_WINGET(LMAT,YLMAT, & !IN
                ROT,DY_STRAIN) !OUT

                CALL D_HUGHES_WINGET(LMAT,ZLMAT, & !IN
                ROT,DZ_STRAIN) !OUT

            END IF
            !
            ! GET THE ROTATION MATRIX AND OBJECTIVE INCREMENTAL
            ! STRAIN USING HUGHES-WINGET ALGORITHM
            !
            CALL HUGHES_WINGET(LMAT,ROT,STRAIN,D)
            !
            ! ROTATE THE TOTAL STRESSES FROM PREVIOUS TIME STEP
            !
            CALL ROTATE_TENSOR(ROT,LSTRESS)
            !
            ! ROTATE THE TOTAL STRAINS FROM PREVIOUS TIME STEP
            !
            CALL ROTATE_TENSOR(ROT,LSTRAIN)
            !
        ELSE
            !
            ! BUILD THE INCREMENTAL INFINTESIMAL STRAIN
            !
            STRAIN = 0.0d0
            !
            !STRAIN ORDERING:
            !XX, YY, ZZ, YZ+ZY, XZ+ZX, XY+XY
            DO J = 1, LN
                STRAIN(1) = STRAIN(1) +  SHPD(1,J)*LDINC(1,J)
                STRAIN(2) = STRAIN(2) +  SHPD(2,J)*LDINC(2,J)
                STRAIN(3) = STRAIN(3) +  SHPD(3,J)*LDINC(3,J)
                STRAIN(4) = STRAIN(4) +  SHPD(2,J)*LDINC(3,J) +  SHPD(3,J)*LDINC(2,J)
                STRAIN(5) = STRAIN(5) +  SHPD(1,J)*LDINC(3,J) +  SHPD(3,J)*LDINC(1,J)
                STRAIN(6) = STRAIN(6) +  SHPD(1,J)*LDINC(2,J) +  SHPD(2,J)*LDINC(1,J)
            END DO
            !
        END IF
        !


        LSTRAIN = LSTRAIN + STRAIN
        !
        ! ELASTIC PREDICTOR
        !
        ELAS_MAT = FORM_CMAT(LPROP)
        LSTRESS_PREDICTOR = LSTRESS + MATMUL(ELAS_MAT,STRAIN)
        !

        IF (LMAT_TYPE.EQ.5) THEN
            CALL HYPERELASTIC(LPROP,LSTRESS,FMAT,LSTRAIN)
        ELSE
            CALL CONSTITUTION(LSTRESS_PREDICTOR,LMAT_TYPE, LSTRAIN, STRAIN, LPROP, DLT, FMAT, & !IN
        LSTATE, LSTRESS, L_H_STRESS, L_S_STRESS) !IN/OUT, OUT
        END IF
        !
        ! ********** SAVE STATE AND FEILD VARIABLES **********
        !
        !
        ! UPDATE STATE VARIABLE TO GSTATE
        !
        DO J = 1, 20
            GSTATE(J,I) = LSTATE(J)
        END DO
        !
        DO J = 1, 6

            !GET INCREMENTS FOR TIME STEP PREDICTION
            STRESS_INC(J) = LSTRESS(J) - GSTRESS(J,I)
            STRAIN_INC(J) = LSTRAIN(J) - GSTRAIN(J,I)

            !SAVE THE STRESSES
            GSTRESS(J,I) = LSTRESS(J)
            GSTRAIN(J,I) = LSTRAIN(J)
			
			IF(LMAT_TYPE == 4) THEN            
				G_H_STRESS(J,I) = L_H_STRESS(J)!GC
				G_S_STRESS(J,I) = L_S_STRESS(J)!GC
			END IF

        END DO
        !EQUIVALENT PLASTIC STRAIN

        GSTRAIN_EQ(I) = LSTRAIN(1)**2 + LSTRAIN(2)**2 + LSTRAIN(3)**2 + &
	               2.0d0*(LSTRAIN(4)**2 + LSTRAIN(5)**2 + LSTRAIN(6)**2)

        GSTRAIN_EQ(I) = ( GSTRAIN_EQ(I) *2/3)**0.5

        ID_RANK = OMP_get_thread_num()
        IF (LFINITE_STRAIN) THEN
            DO J = 1, 6
            
                 GINT_WORK_TEMP(ID_RANK+1) = GINT_WORK_TEMP(ID_RANK+1) + 0.5d0*D(J)*(2*LSTRESS(J)-STRESS_INC(J))*VOL*DET
            END DO
        ELSE
        ID_RANK = OMP_get_thread_num()
            DO J = 1, 6
                GINT_WORK_TEMP(ID_RANK+1) = GINT_WORK_TEMP(ID_RANK+1) + 0.5d0*STRAIN_INC(J)*STRESS_INC(J)*VOL*DET
            END DO
        END IF
        

        POISS = LPROP(1)
        YOUNG = LPROP(2)

        BULK = BULK_MOD(YOUNG,POISS)

        SHEAR = SHEAR_MOD(YOUNG,POISS)

        DENSITY =  LPROP(3)
		
		!IF (.FALSE.) THEN !HERE'S THE OLD WAY OF DOING TIME STEP
			
			IF (LMAT_TYPE.GT.1) THEN
				NSNI_FLAG=.FALSE.
				CALL ESTIMATE_MODULI(STRESS_INC, STRAIN_INC, SHEAR_TRIAL, BULK_TRIAL, SHEAR, BULK,NSNI_FLAG)
			END IF

			  PMOD = BULK + 4.0d0*SHEAR/3.0d0
			
			  MAXMOD=MAX(PMOD,SHEAR)

			  GMAX_WVEL(I) = DSQRT(MAXMOD/DENSITY)

			  !IF (LMAT_TYPE.EQ.3) THEN
			  !	!FUDGE THE DRUCKER-PRAGER TIME STEP SO THAT THE FACTOR CAN BE 1.0
			  !	GMAX_WVEL(I) = GMAX_WVEL(I)/0.3d0
			  !END IF

		!ELSE
		  !
		  ! DO IT THE WAY DR. YREUAX DOES
		  !
          !GMAX_WVEL(I) = DSQRT(BULK/DENSITY)
          !
		!END IF
		
        IF (ITYPE_INT.EQ.2) THEN

            DO J = 1, 6
                LDX_STRESS(J) = LOCAL_DX_STRESS(J,I)
                LDY_STRESS(J) = LOCAL_DY_STRESS(J,I)
                LDZ_STRESS(J) = LOCAL_DZ_STRESS(J,I)
            END DO

            CALL ROTATE_TENSOR(ROT,LDX_STRESS)
            CALL ROTATE_TENSOR(ROT,LDY_STRESS)
            CALL ROTATE_TENSOR(ROT,LDZ_STRESS)

            POISS = LPROP(1)
            YOUNG = LPROP(2)

            BULK = BULK_MOD(YOUNG,POISS)

            SHEAR = SHEAR_MOD(YOUNG,POISS)

            IF (LMAT_TYPE.GT.1) THEN
            !IF (.TRUE.) THEN
                NSNI_FLAG=.TRUE.
                CALL ESTIMATE_MODULI(STRESS_INC, STRAIN_INC, SHEAR_TRIAL, BULK_TRIAL, SHEAR, BULK,NSNI_FLAG)
            END IF

            LAMDA = LAMDA_MOD(BULK,SHEAR)
            MU = SHEAR
            LAMDA_PLUS_2MU = LAMDA + 2.0d0*MU

            CMAT = 0.0d0

            CMAT(1,1) = LAMDA_PLUS_2MU
            CMAT(2,2) = LAMDA_PLUS_2MU
            CMAT(3,3) = LAMDA_PLUS_2MU
            CMAT(4,4) = MU
            CMAT(5,5) = MU
            CMAT(6,6) = MU

            CMAT(1,2) = LAMDA
            CMAT(2,1) = LAMDA

            CMAT(1,3) = LAMDA
            CMAT(3,1) = LAMDA

            CMAT(3,2) = LAMDA
            CMAT(2,3) = LAMDA

			NSNI_LIMITER = 1.0d0
            IF ((LMAT_TYPE.EQ.3).OR.(LMAT_TYPE.EQ.6)) THEN
			!IF (LMAT_TYPE.EQ.3) THEN
            !
            ! DAMAGE MECHANICS INVOLVED, DO NOT USE A "TOTAL" STRESS
            ! STABILIZATION, INSTEAD, USE THE INCREMENTAL STRESS
            ! FOR STABILIZATION.
			!
			! COMMENT #2: STILL INEFFECTIVE, ZERO-OUT THE STRESS
			! IN CASE THE DAMAGE GETS TOO BIG, THIS SEEMS TO WORK
			! OK, BUT THE VALUE IS SENSATIVE A BIT.
            !
			IF (LSTATE(4).GT.(0.5d0)) THEN
                NSNI_LIMITER = 0.0d0
			ELSE
                NSNI_LIMITER = (1.0d0-2.0d0*LSTATE(4))
			END IF
            END IF
            !
            ! UPDATE THE PSUEDO-STRESSES FOR NSNI
            !
            DO K = 1, 6
                DO L = 1, 6
                    LDX_STRESS(K) = LDX_STRESS(K) +  CMAT(K,L)*DX_STRAIN(L)
                    LDY_STRESS(K) = LDY_STRESS(K) +  CMAT(K,L)*DY_STRAIN(L)
                    LDZ_STRESS(K) = LDZ_STRESS(K) +  CMAT(K,L)*DZ_STRAIN(L)
                END DO
            END DO
            !
            ! SAVE WORK CONGUGATE STRESS DERIVATIVES FOR NSNI
            !
            DO J = 1, 6
                !
                LOCAL_DX_STRESS(J,I) = LDX_STRESS(J)*NSNI_LIMITER
                LOCAL_DY_STRESS(J,I) = LDY_STRESS(J)*NSNI_LIMITER
                LOCAL_DZ_STRESS(J,I) = LDY_STRESS(J)*NSNI_LIMITER
                !
            END DO
			
			!DOESNT WORK!
			!IF ((LMAT_TYPE.EQ.3).OR.(LMAT_TYPE.EQ.6)) THEN
			!LDX_STRESS = LDX_STRESS*(1.0d0-LSTATE(4))
			!LDY_STRESS = LDY_STRESS*(1.0d0-LSTATE(4))
			!LDX_STRESS = LDX_STRESS*(1.0d0-LSTATE(4))
			!END IF


        END IF !NSNI
XNORM(1:3) =0.D0
        DO K = 1, LN
            KK = LSTACK(K)
            IF(LOCAL_BODY_ID .EQ.MODEL_BODY_ID(KK)) THEN
                XNORM(1) = XNORM(1)+SHPD(1,K)
                XNORM(2) = XNORM(2)+SHPD(2,K)
                XNORM(3) = XNORM(3)+SHPD(3,K)
            ELSE
                XNORM(1) = XNORM(1)-SHPD(1,K)
                XNORM(2) = XNORM(2)-SHPD(2,K)
                XNORM(3) = XNORM(3)-SHPD(3,K)
            ENDIF

        END DO
        !
        ! ASSEMBLE THE INTERNAL FORCE
        !
        MAG_FINT = 0.0d0
        !
        DO J = 1, LN

            JJ = LSTACK(J)

            !BMAT = 0.0d0

            !VOIGT ORDERING:
            !XX, YY, ZZ, YZ, XZ, XY
            BMAT = 0.0d0
            BMAT(1,1) = SHPD(1,J)
            BMAT(2,2) = SHPD(2,J)
            BMAT(3,3) = SHPD(3,J)
            BMAT(4,2) = SHPD(3,J)
            BMAT(4,3) = SHPD(2,J)
            BMAT(5,1) = SHPD(3,J)
            BMAT(5,3) = SHPD(1,J)
            BMAT(6,1) = SHPD(2,J)
            BMAT(6,2) = SHPD(1,J)

            BMAT_T = TRANSPOSE(BMAT)

            DENSITY=LPROP(3)

            !FINT3(1) = LSTRESS(1) * SHPD(1,J) + LSTRESS(5) * SHPD(3,J) + LSTRESS(6) * SHPD(2,J)

            !FINT3(2) = LSTRESS(2) * SHPD(2,J) + LSTRESS(4) * SHPD(3,J) + LSTRESS(6) * SHPD(1,J)

            !FINT3(3) = LSTRESS(3) * SHPD(3,J) + LSTRESS(4) * SHPD(2,J) + LSTRESS(5) * SHPD(1,J)

            FINT3 = MATMUL(BMAT_T,LSTRESS)            

            

   !
   ! DO KERNEL CONTACT
   !

           F_INT_C_TEMP=0.D0

           F_INT_C=0.D0
IF (KCONTACT) THEN

    LOCAL_BODY_ID_2 = MODEL_BODY_ID(JJ)
    MU1 = LPROP(20) !BODY 1
    MU_NEW = GPROP(20,JJ) !BODY 2
        IF(LOCAL_BODY_ID .NE. LOCAL_BODY_ID_2) THEN
    IF (IKCONTACT.EQ.1) THEN
        ! NODAL ORIENTATION TO GET THE XNORM

            XNORM(1:3) =0.D0
            X2(1) = GCOO_CUURENT(1,JJ)
            X2(2) = GCOO_CUURENT(2,JJ)
            X2(3) = GCOO_CUURENT(3,JJ)
            XNORM(1:3) = LCOO_T(1:3) - X2(1:3)
            TEMP = DSQRT(XNORM(1)**2.0D0 + XNORM(2)**2.0D0 + XNORM(3)**2.0D0)
        IF(TEMP > 1e-10) THEN
            XNORM(1:3) = XNORM(1:3) / TEMP
        ENDIF


    ELSEIF (IKCONTACT.EQ.2) THEN
        ! LEVEL SET TO GET THE XNORM

        TEMP = DSQRT(XNORM(1)**2.0D0 + XNORM(2)**2.0D0 + XNORM(3)**2.0D0)
        IF(TEMP > 1e-10) THEN
            XNORM(1:3) = XNORM(1:3) / TEMP
        ENDIF

    ENDIF

    F_N = FINT3(1) * XNORM(1) + FINT3(2) * XNORM(2) + FINT3(3) * XNORM(3)

    F_T1 = FINT3(1) - XNORM(1) * F_N ! Ft_x
    F_T2 = FINT3(2) - XNORM(2) * F_N ! Ft_y
    F_T3 = FINT3(3) - XNORM(3) * F_N ! Ft_z

    ! Length of Ft
    F_T = DSQRT(F_T1**2.0D0 + F_T2**2.0D0 + F_T3**2.0D0)
    MU_NEW2 = (MU1+ MU_NEW) * 0.5D0

    IF(F_T .GT. 1E-13) THEN
        ! minimum of Ft and mu * Fn (Ft <= mu * Fn)
        F_TT= MIN(DABS(F_N*MU_NEW2),F_T)
        ! Fn + Ft_modified
        F_INT_C_TEMP(1) = F_N * XNORM(1) +  F_TT * F_T1 / F_T
        F_INT_C_TEMP(2) = F_N * XNORM(2) +  F_TT * F_T2 / F_T
        F_INT_C_TEMP(3) = F_N * XNORM(3) +  F_TT * F_T3 / F_T

    ENDIF
    !F_INT_C = F_INT_C + F_INT_C_TEMP
FINT3 = FINT3 + F_INT_C_TEMP
       ENDIF
ENDIF

            

            !GRAVITY
            FGRAV = SHP(J) * IGRAVITY*DENSITY
            
            !BODY FORCE
            FBOD = SHP(J) * LBOD*DENSITY
                        
            FINT3_EXT = FBOD + FGRAV

            DO K = 1, 3
                MAG_FINT = MAG_FINT + FINT3(K)**2
            END DO

            DO K = 1, 3
                ID_RANK = OMP_get_thread_num()  !OMPJOE

                FINT_TEMP(ID_RANK+1,K,JJ) = FINT_TEMP(ID_RANK+1,K,JJ) + FINT3(K)*VOL*DET

                FEXT_TEMP(ID_RANK+1,K,JJ) = FEXT_TEMP(ID_RANK+1,K,JJ) + FINT3_EXT(K)*VOL*DET

            END DO

        END DO !ASSEMBLE FINT FOR STANDARD NODAL INTEGRATION PART

        MAG_FINT=DSQRT(MAG_FINT)

        IF (ITYPE_INT.EQ.2) THEN !NSNI

            !
            MAG_STAB_FINT = 0.0d0
            !
            DO J = 1, LN

                JJ = LSTACK(J)

                XBMAT = 0.0d0
                YBMAT = 0.0d0
                ZBMAT = 0.0d0

                XBMAT(1,1) = SHPDD_SM(XMAP(1),J)
                XBMAT(2,2) = SHPDD_SM(XMAP(2),J)
                XBMAT(3,3) = SHPDD_SM(XMAP(3),J)
                XBMAT(4,2) = SHPDD_SM(XMAP(3),J)
                XBMAT(4,3) = SHPDD_SM(XMAP(2),J)
                XBMAT(5,1) = SHPDD_SM(XMAP(3),J)
                XBMAT(5,3) = SHPDD_SM(XMAP(1),J)
                XBMAT(6,1) = SHPDD_SM(XMAP(2),J)
                XBMAT(6,2) = SHPDD_SM(XMAP(1),J)

                XBMAT_T = TRANSPOSE(XBMAT)

                XFINT3(J,1:3) = MATMUL(XBMAT_T,LDX_STRESS)



                YBMAT(1,1) = SHPDD_SM(YMAP(1),J)
                YBMAT(2,2) = SHPDD_SM(YMAP(2),J)
                YBMAT(3,3) = SHPDD_SM(YMAP(3),J)
                YBMAT(4,2) = SHPDD_SM(YMAP(3),J)
                YBMAT(4,3) = SHPDD_SM(YMAP(2),J)
                YBMAT(5,1) = SHPDD_SM(YMAP(3),J)
                YBMAT(5,3) = SHPDD_SM(YMAP(1),J)
                YBMAT(6,1) = SHPDD_SM(YMAP(2),J)
                YBMAT(6,2) = SHPDD_SM(YMAP(1),J)

                YBMAT_T = TRANSPOSE(YBMAT)

                YFINT3(J,1:3) = MATMUL(YBMAT_T,LDY_STRESS)



                ZBMAT(1,1) = SHPDD_SM(ZMAP(1),J)
                ZBMAT(2,2) = SHPDD_SM(ZMAP(2),J)
                ZBMAT(3,3) = SHPDD_SM(ZMAP(3),J)
                ZBMAT(4,2) = SHPDD_SM(ZMAP(3),J)
                ZBMAT(4,3) = SHPDD_SM(ZMAP(2),J)
                ZBMAT(5,1) = SHPDD_SM(ZMAP(3),J)
                ZBMAT(5,3) = SHPDD_SM(ZMAP(1),J)
                ZBMAT(6,1) = SHPDD_SM(ZMAP(2),J)
                ZBMAT(6,2) = SHPDD_SM(ZMAP(1),J)

                ZBMAT_T = TRANSPOSE(ZBMAT)

                ZFINT3(J,1:3) = MATMUL(ZBMAT_T,LDZ_STRESS)

                DO K = 1, 3
                    MAG_STAB_FINT = MAG_STAB_FINT + (XFINT3(J,K)**2 + YFINT3(J,K)**2 + ZFINT3(J,K)**2)
                END DO
                
                CONTINUE


            END DO
            !
            ! CONTROL THE CONTRIBUTION TO FINT BY NSNI: SOME PARAMETERS ARE ESTIMATED AND
            ! THEY MIGHT NOT BE ACCURATE
            !
            IF (USE_STAB_CONTROL) THEN
             IF (MAG_STAB_FINT.GT.(1.0d-12)) THEN
                MAG_STAB_FINT=DSQRT(MAG_STAB_FINT)
                IF (MAG_STAB_FINT.GT.MAG_FINT) THEN
                    XFINT3=XFINT3*MAG_FINT/MAG_STAB_FINT*STABILIZATION_CONTROL_COEF
                    YFINT3=YFINT3*MAG_FINT/MAG_STAB_FINT*STABILIZATION_CONTROL_COEF
                    ZFINT3=ZFINT3*MAG_FINT/MAG_STAB_FINT*STABILIZATION_CONTROL_COEF
                END IF
             END IF
            END IF
            
            !DEBUG
            !IF (MAG_STAB_FINT.GT.(1.0e-6)) THEN
            !CONTINUE
            !END IF

            DO J = 1, LN

                JJ = LSTACK(J)

                DO K = 1, 3
                    !IT DOESNT LOOK LIKE X_MOM GETS ASSIGNED ANYTHING! FIX NSNI!
                    ID_RANK = OMP_get_thread_num()
                    FINT_TEMP(ID_RANK+1,K,JJ) = FINT_TEMP(ID_RANK+1,K,JJ) + XFINT3(J,K) *VOL*DET * G_X_MOM(I)
                    FINT_TEMP(ID_RANK+1,K,JJ) = FINT_TEMP(ID_RANK+1,K,JJ) + YFINT3(J,K) *VOL*DET * G_Y_MOM(I)
                    FINT_TEMP(ID_RANK+1,K,JJ) = FINT_TEMP(ID_RANK+1,K,JJ) + ZFINT3(J,K) *VOL*DET * G_Z_MOM(I)

                END DO

            END DO

        END IF !NSNI


    END DO !INTEGRATION POINT (NODE) LOOP
    !$OMP END DO
    !$OMP END PARALLEL



    !$OMP PARALLEL PRIVATE(ID_RANK) SHARED(NCORES_INPUT,GINT_WORK_TEMP)
    GINT_WORK =  GINT_WORK+SUM(GINT_WORK_TEMP(1:NCORES_INPUT))
    !$OMP END PARALLEL

    !
    !FINT_TEMP TO HOLD THE VALUES FOR OPENMP REDUCE(ASSEMBLE,ADD) IN THE END
    !
    !$OMP PARALLEL PRIVATE(I,K,ID_RANK) SHARED(FINT_TEMP,FEXT_TEMP,NCORES_INPUT,GINT_WORK_TEMP)
    !$OMP DO
    DO I = 1, GNUMP
        DO K = 1, 3
            FINT((I-1)*3+K) =  SUM(FINT_TEMP(1:NCORES_INPUT,K,I))
            FEXT((I-1)*3+K) =  SUM(FEXT_TEMP(1:NCORES_INPUT,K,I))
        END DO
    END DO
    !$OMP END DO
    !$OMP END PARALLEL


    IF (AUTO_TS) THEN
        !DO TIME STEP CALCS

        DO I = 1, GNUMP

            LN = GN(I)
            LSTART = GSTART(I)
            !
            ! GET THE NEIGHBOR LIST
            !
            DO J = 1, LN
                LSTACK(J) = GSTACK(LSTART+J-1)
            END DO

            !FIND THE CHARACTERISTIC DISTANCES

            XI=GCOO_CUURENT(1,I)
            YI=GCOO_CUURENT(2,I)
            ZI=GCOO_CUURENT(3,I)
                    !
					! USE THE UNDEFORMED CONFIGURATION
					!
            XI=GCOO(1,I)
            YI=GCOO(2,I)
            ZI=GCOO(3,I)

            FIRST = .TRUE.

			IF (LINIT) THEN
			
            DO J = 1, LN

                JJ = LSTACK(J)

                IF (JJ.NE.I) THEN

                    XJ=GCOO_CUURENT(1,JJ)
                    YJ=GCOO_CUURENT(2,JJ)
                    ZJ=GCOO_CUURENT(3,JJ)
                    !
					! USE THE UNDEFORMED CONFIGURATION
					!
                    XJ=GCOO(1,JJ)
                    YJ=GCOO(2,JJ)
                    ZJ=GCOO(3,JJ)

                    DIST = DSQRT((XJ-XI)**2 + (YJ-YI)**2 + (ZJ-ZI)**2)

                    IF (FIRST) THEN
                        GCHAR_DIST(I) = DIST
                        FIRST = .FALSE.
                    ELSE
                        GCHAR_DIST(I) = MIN(GCHAR_DIST(I),DIST)
                    END IF

                END IF

            END DO !J=1,GNUMP (NEIGHBOR NODES)
			
			END IF

            DLT_TEMP = GCHAR_DIST(I) / GMAX_WVEL(I) !* 0.2d0


            IF (I.EQ.1) THEN
                DLT_FINT = DLT_TEMP
            ELSE

                IF (DLT_TEMP.LT.DLT_FINT) THEN
                    DLT_FINT = DLT_TEMP
                END IF
                DLT_FINT = MIN(DLT_TEMP,DLT_FINT)
            END IF

        END DO

        DLT_FINT = DLT_FINT*DLT_FAC



    END IF !CALC TIME STEP


    DEALLOCATE(FINT_TEMP)
    DEALLOCATE(GINT_WORK_TEMP)
    RETURN
    END SUBROUTINE




